import tkinter as tk
from tkinter import ttk, messagebox
from tkinter import filedialog
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
import json
import csv
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk


# --- Expense Class ---

class Expense:
    """Class for expense data."""

    static_id = 0  # Class variable to assign unique IDs

    def __init__(self, amount: float, category: str, date: str = None, id: int = None):
        """
        Initializes an Expense object.

        Args:
            amount (float): The monetary value of the expense.
            category (str): The category of the expense (e.g., Food, Rent).
            date (str, optional): The date of the expense. Defaults to today's date.
        """
        if date is None:
            self.date = datetime.now().strftime("%Y-%m-%d")
        else:
            self.date = date
            
        if id is not None:
            self.id = id   
        else:  
            self.id = Expense.static_id
        Expense.static_id += 1

        self.amount = amount
        self.category = category
        

    def __str__(self) -> str:
        return f"{self.date} | {self.category}: ${self.amount:.2f}"

    def to_dict(self) -> Dict[str, Any]:
        """Returns a dictionary representation for easy saving."""
        return {"id": self.id, "date": self.date, "amount": self.amount, "category": self.category}


# --- Model ---

class ExpenseTracker:
    """Handles the list of expenses and file I/O."""
    def __init__(self, filename: str = "expenses.csv"):
        self.expenses: List[Expense] = []
        self.filename = filename
        self._load_data()

    def add_expense(self, amount: float, category: str, date: Optional[str] = None):
        """Creates an Expense object and adds it to the list."""
        try:
            expense = Expense(amount, category, date)
            self.expenses.append(expense)
            self._save_data()
        except ValueError:
            # Handle cases where amount is not convertible to float
            print("Error: Invalid amount provided.")

    def remove_expense_by_id(self, expense_id: int) -> bool:
        """Removes an expense from the list by ID. """
        old_count = len(self.expenses)
        
        # Use a list comprehension to filter out the expense with the matching ID
        self.expenses = [
            expense for expense in self.expenses 
            if expense.id != expense_id
        ]
        
        new_count = len(self.expenses)

        # Check if the list length changed
        if new_count < old_count:
            print(f"Removed expense with ID: {expense_id}")
            self._save_data() # Save the updated list to file
            return True
        else:
            print(f"Error: Expense with ID {expense_id} not found.")
            return False

    def get_spending_data_for_chart(self) -> Tuple[List[str], List[float]]:
        """
        Aggregates data by category and returns lists of labels and values
        ready for plotting.
        """
        summary = self.get_summary_by_category()
        
        # Filter out zero amounts and separate keys/values
        labels = []
        values = []
        for category, amount in summary.items():
            if amount > 0:
                labels.append(category)
                values.append(amount)
                
        return labels, values

    def get_summary_by_category(self) -> Dict[str, float]:
        """Calculates the total expense for each category."""
        summary: Dict[str, float] = {}
        for expense in self.expenses:
            summary[expense.category] = summary.get(expense.category, 0.0) + expense.amount
        return summary

    def get_all_expenses_data(self) -> List[Dict[str, Any]]:
        """Returns a list of dictionaries for display in the GUI."""
        return [exp.to_dict() for exp in self.expenses]
    
    def get_total_expense(self) -> float:
        """Returns the total of all recorded expenses."""
        return sum(exp.amount for exp in self.expenses)
    
    def _reset_expenses(self):
        """Clears all expenses (for testing purposes)."""
        self.expenses = []
        Expense.static_id = 0
        self._save_data()

    def get_filtered_expenses(self, category: Optional[str]) -> List[Expense]:
        """Returns a list of expenses by category."""
        if category and category != "All":
            return [
                exp for exp in self.expenses 
                if exp.category == category
            ]
        # If no filter is applied, return all expenses
        return self.expenses 

    def export_expenses_to_csv(self, filepath: str) -> bool:
        """
        Exports all current expense data to a specified CSV file path.
        """
        if not self.expenses:
            print("Export failed: No expenses to save.")
            return False

        # Get the data as a list of dictionaries
        data_to_export = [exp.to_dict() for exp in self.expenses]
        
        # Define the column headers for the CSV file
        fieldnames = ['id', 'date', 'category', 'amount'] 

        try:
            with open(filepath, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

                writer.writeheader() # Writes the column headers
                writer.writerows(data_to_export) # Writes the data rows
            
            return True
        except IOError:
            print(f"Error: Could not write to file {filepath}")
            return False

    # File I/O methods
    def _load_data(self):
        """Loads expenses from the JSON file and updates the static ID."""
    
        loaded_data = []
        try:
            with open(self.filename, 'r') as f:
                loaded_data = json.load(f)
        except FileNotFoundError:
            print(f"File {self.filename} not found. Starting with empty list.")
            return # Start empty if no file exists
        except json.JSONDecodeError:
            print(f"Error reading JSON from {self.filename}.")
            return

        max_id = -1
        for item in loaded_data:
            # Recreate the Expense object from the loaded dictionary item
            new_expense = Expense(
                amount=item['amount'],
                category=item['category'],
                date=item['date'],
                # The loaded expense must use its original ID, not a new one
                id=item['id'] 
            )
            self.expenses.append(new_expense)
            
            # Track the maximum ID found
            if item['id'] > max_id:
                max_id = item['id']

        # Set the static counter to the next available ID
        if max_id != -1:
            Expense.static_id = max_id + 1
            print(f"ID counter synchronized to {Expense.static_id}")
        
        print(f"Loaded {len(self.expenses)} expenses.")
        

    def _save_data(self):
        """Saves the current list of expenses to a json file."""
        data_to_save = [exp.to_dict() for exp in self.expenses]

        try:
            with open(self.filename, 'w') as f:
                # try to make readable with indent=4
                json.dump(data_to_save, f, indent=4)
            print(f"Saved {len(self.expenses)} expenses to {self.filename}")
        except IOError:
            print(f"Error: Could not write to file {self.filename}")

        

# --- Dialog Classes ---
# --- Add Expense Dialog ---

class AddExpenseDialog(tk.Toplevel):
    """
    Modal dialog for adding a new expense.
    Collects Amount, Category, and Date.
    """
    def __init__(self, master: tk.Tk, categories: List[str]):
        super().__init__(master)
        self.transient(master) # Keep the dialog on top of the main window
        self.title("Add New Expense")
        
        # Data storage and variables
        self.result: Optional[Tuple[float, str, str]] = None
        self.amount_var = tk.StringVar()
        self.category_var = tk.StringVar(value=categories[0])
        self.date_var = tk.StringVar(value=datetime.now().strftime("%Y-%m-%d"))

        self._create_widgets(categories)
        
        # Make the dialog modal
        self.grab_set()
        master.wait_window(self) # Execution pauses here until dialog is destroyed

    def _create_widgets(self, categories: List[str]):
        main_frame = ttk.Frame(self, padding="15")
        main_frame.pack(fill="both", expand=True)

        # Input Fields
        ttk.Label(main_frame, text="Amount ($):").grid(row=0, column=0, sticky="w", pady=5)
        ttk.Entry(main_frame, textvariable=self.amount_var).grid(row=0, column=1, padx=5, sticky="ew")

        ttk.Label(main_frame, text="Category:").grid(row=1, column=0, sticky="w", pady=5)
        ttk.OptionMenu(main_frame, self.category_var, self.category_var.get(), *categories).grid(row=1, column=1, padx=5, sticky="ew")

        ttk.Label(main_frame, text="Date:").grid(row=2, column=0, sticky="w", pady=5)
        ttk.Entry(main_frame, textvariable=self.date_var).grid(row=2, column=1, padx=5, sticky="ew")

        # Buttons
        btn_frame = ttk.Frame(main_frame)
        btn_frame.grid(row=3, column=0, columnspan=2, pady=10)
        
        ttk.Button(btn_frame, text="Submit", command=self._on_submit).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Cancel", command=self.destroy).pack(side="right", padx=5)
        
    def _on_submit(self):
        """Validates input, saves result, and closes the window."""
        try:
            amount = float(self.amount_var.get())
            date = self.date_var.get()
            
            if amount <= 0:
                messagebox.showerror("Input Error", "Amount must be positive.")
                return # Exit early
                
            # Store the validated data in the result attribute
            self.result = (amount, self.category_var.get(), date)
            
            # Close the dialog, which releases the wait_window call in the main class
            self.destroy() 
            
        except ValueError:
            messagebox.showerror("Input Error", "Invalid Amount or Date format.")
            return # Exit early

# --- Remove Expense Dialog ---

class RemoveExpenseDialog(tk.Toplevel):
    """
    Modal dialog for removing an expense.
    Collects the Expense ID.
    """
    def __init__(self, master: tk.Tk):
        super().__init__(master)
        self.transient(master)
        self.title("Remove Expense")
        
        self.result: Optional[int] = None
        self.id_var = tk.StringVar()
        
        self._create_widgets()
        self.grab_set()
        master.wait_window(self)

    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding="15")
        main_frame.pack(fill="both", expand=True)
        
        ttk.Label(main_frame, text="Enter Expense ID:").grid(row=0, column=0, padx=5, pady=5)
        ttk.Entry(main_frame, textvariable=self.id_var, width=15).grid(row=0, column=1, padx=5, pady=5)

        # Buttons
        btn_frame = ttk.Frame(main_frame)
        btn_frame.grid(row=1, column=0, columnspan=2, pady=10)
        
        ttk.Button(btn_frame, text="Remove", command=self._on_submit).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Cancel", command=self.destroy).pack(side="right", padx=5)

    def _on_submit(self):
        """Validates ID input, saves result, and closes the window."""
        try:
            expense_id = int(self.id_var.get())
            self.result = expense_id
            self.destroy()
        except ValueError:
            messagebox.showerror("Input Error", "ID must be a whole number.")
            return # Exit early


# --- Visualization Dialog ---

class ChartDialog(tk.Toplevel):
    """Modal dialog to display expense visualizations."""
    def __init__(self, master: tk.Tk, tracker: 'ExpenseTracker'):
        super().__init__(master)
        self.transient(master)
        self.title("Spending Visualization")
        
        self.tracker = tracker
        
        self._create_widgets()

        # Make the dialog modal
        self.grab_set()
        master.wait_window(self)

    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill="both", expand=True)
        
        # Get data from the model
        labels, values = self.tracker.get_spending_data_for_chart()
        
        if not values:
            ttk.Label(main_frame, text="No expense data available to chart.").pack(pady=20)
            return

        # Create a Matplotlib Figure
        fig = Figure(figsize=(7, 6), dpi=100)
        ax = fig.add_subplot(111)

        # Draw the Pie Chart with placement controls
        wedges, texts, autotexts = ax.pie(
            values, 
            labels=labels, 
            autopct='%1.1f%%', 
            startangle=90,
            textprops={'fontsize': 9},
            
            # --- FIX OVERLAP ---
            pctdistance=0.8, 
            labeldistance=1.1 # Pushes category labels slightly further out
        )
        ax.set_title("Spending Breakdown by Category")
        
        # Create the Tkinter Canvas Bridge
        canvas = FigureCanvasTkAgg(fig, master=main_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        # Add the Navigation Toolbar
        toolbar = NavigationToolbar2Tk(canvas, main_frame)
        toolbar.update()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        # Close button
        ttk.Button(main_frame, text="Close Chart", command=self.destroy).pack(pady=10)


# --- GUI Class ---

class ExpenseTrackerGUI:
    """Sets up the Tkinter GUI and interacts with the ExpenseTracker model."""
    def __init__(self, master: tk.Tk, tracker: ExpenseTracker):
        self.master = master
        self.tracker = tracker
        master.title("Personal Expense Tracker")
        
        self.categories = ["Food", "Rent", "Transport", "Clothes", "Home & Utilities", "Other"]

        self.filter_var = tk.StringVar(master, value="Filter by...")

        self._create_widgets()
        self._setup_expense_list()
        self._update_display()

    def _create_widgets(self):
        """Sets up the main input and control widgets."""
        
        # Main button frame (for add and remove so far)
        main_button_frame = ttk.LabelFrame(self.master, text="Expense Tracker Operations", padding="10")
        main_button_frame.pack(padx=10, pady=10, fill="x")

        # Add button
        ttk.Button(main_button_frame, text="Add Expense", command=self._open_add_dialog).grid(row=0, column=0, columnspan=2, pady=10)

        # Remove button
        ttk.Button(main_button_frame, text="Remove Expense", command=self._open_remove_dialog).grid(row=0, column=2, padx=10)

        # Export Button
        ttk.Button(main_button_frame, text="Export CSV", command=self._export_data_handler).grid(row=1, column=0, padx=10) # Using column 4 for placement

        # View Charts Button
        ttk.Button(main_button_frame, text="View Charts", command=self._open_chart_dialog).grid(row=1, column=2, padx=10)


        # Filter by.. dropdown
        filter_dropdown = ttk.Combobox(
            main_button_frame,
            values=["Filter by...", "All"] + self.categories,
            state="readonly",
            textvariable=self.filter_var,
            width=15,
        )
        filter_dropdown.grid(row=0, column=3, padx=10)

        # Bind the event to the handler method
        filter_dropdown.bind('<<ComboboxSelected>>', self._filter_handler)


        # --- Summary Label ---
        self.total_label = ttk.Label(self.master, text="Total Expenses: $0.00", font=('Arial', 12, 'bold'))
        self.total_label.pack(pady=5)

    def _open_chart_dialog(self):
        """Opens the modal dialog with the spending chart."""
        # The dialog will automatically pull the data from self.tracker
        ChartDialog(self.master, self.tracker)

    def _setup_expense_list(self):
        """Sets up the Treeview widget and links it to a vertical Scrollbar."""

        # Create a Frame to hold the Treeview and Scrollbar together
        tree_frame = ttk.Frame(self.master, padding="10")
        tree_frame.pack(padx=10, pady=5, fill="both", expand=True)

        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        columns = ("ID", "Date", "Category", "Amount")
        
        self.expense_list = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show='headings',
            yscrollcommand=scrollbar.set # Links Treeview's scrolling to the scrollbar's position
        )
        self.expense_list.pack(side=tk.LEFT, fill="both", expand=True)

        scrollbar.config(command=self.expense_list.yview)

        # Column headings
        self.expense_list.heading("ID", text="ID")
        self.expense_list.column("ID", anchor=tk.CENTER, width=50)

        self.expense_list.heading("Date", text="Date")
        self.expense_list.column("Date", anchor=tk.CENTER, width=100)

        self.expense_list.heading("Category", text="Category")
        self.expense_list.column("Category", anchor=tk.CENTER, width=100)

        self.expense_list.heading("Amount", text="Amount")
        self.expense_list.column("Amount", anchor=tk.CENTER, width=80)

        # Enable sorting by clicking on column headers
        for col in columns:
            self.expense_list.heading(col, text=col, 
                command=lambda c=col: self._sort_treeview(c, False)) # Pass column name
            
    def _export_data_handler(self):
        """Prompts user for save location and triggers the CSV export."""
        
        # Open the 'Save As' file dialog
        filepath = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save Expense Data"
        )

        if not filepath:
            # User canceled the dialog
            return

        # Call Model's export method
        success = self.tracker.export_expenses_to_csv(filepath)

        # Provide feedback
        if success:
            messagebox.showinfo("Export Success", f"Expense data saved to:\n{filepath}")
        else:
            messagebox.showerror("Export Failed", "Could not save data. Check console for details.")

    def _sort_treeview(self, col: str, reverse: bool):
        """Sorts the Treeview data when a column header is clicked."""

        # Get all data items and their values for the selected column
        data = [(self.expense_list.set(k, col), k) 
                for k in self.expense_list.get_children('')]

        # Sort the data list based on the column value
        if col == "Amount":
            data.sort(key=lambda x: float(x[0].replace('$', '').replace(',', '')), reverse=reverse)
        elif col == "ID":
            data.sort(key=lambda x: int(x[0]), reverse=reverse)
        else:
            data.sort(key=lambda x: x[0], reverse=reverse)

        # Reinsert the sorted data into the Treeview
        for index, (val, k) in enumerate(data):
            self.expense_list.move(k, '', index)

        # Reverse the sort order for the next click
        self.expense_list.heading(col, 
            command=lambda c=col: self._sort_treeview(c, not reverse))

    def _filter_handler(self, event=None):
        """Handles filtering the expense list based on the selected category. Can be called without event to keep filter settings."""
        selected_category = self.filter_var.get()
        
        # Check for placeholder or "All" option
        if selected_category == "Filter by..." or selected_category == "All":
            # If showing all, use the Model's usual data
            data_to_display = self.tracker.get_all_expenses_data()
        else:
            # Get filtered list (Expense objects) from the model
            filtered_objects = self.tracker.get_filtered_expenses(selected_category)
            
            # Convert Expense objects to dicts for display
            data_to_display = [exp.to_dict() for exp in filtered_objects]

        # Update display with filtered data
        self._update_display(data_to_display)

    def _open_add_dialog(self):
        """Opens the dialog for adding an expense and completes the removal process"""
        dialog = AddExpenseDialog(self.master, self.categories)
        
        if dialog.result:
            # Unpack the returned tuple (amount, category, date)
            amount, category, date = dialog.result 
            
            try:
                # Add the expense to the Model
                self.tracker.add_expense(amount, category, date)
                self._filter_handler(None) # Refresh display with current filter
                messagebox.showinfo("Success", "Expense added.")
            except Exception as e:
                # Catch any unexpected errors
                messagebox.showerror("Error", f"Failed to add expense: {e}")

    def _open_remove_dialog(self):
        """Opens the modal dialog for removing an expense by ID and handles the result."""
        dialog = RemoveExpenseDialog(self.master)
        
        if dialog.result is not None:
            expense_id = dialog.result
            
            # Call the Model function
            success = self.tracker.remove_expense_by_id(expense_id)
            
            if success:
                self._filter_handler(None) # Refresh display with current filter
                messagebox.showinfo("Success", f"Expense ID {expense_id} removed.")
            else:
                messagebox.showerror("Error", f"Expense ID {expense_id} not found.")

    
    def _update_display(self, expense_data: Optional[List[Dict[str, Any]]] = None):
        """Refreshes the Treeview list and the summary label."""

        # If no specific data is passed (e.g., on initialization), get ALL data
        if expense_data is None:
            expense_data = self.tracker.get_all_expenses_data()

        # Clear existing list items
        for item in self.expense_list.get_children():
            self.expense_list.delete(item)
            
        # Calculate the total of the currently displayed expenses
        filtered_total = sum(float(expense['amount']) for expense in expense_data)

        # Get data from the Model and insert into Treeview
        for expense in expense_data: # Iterate over the provided list of dicts
            self.expense_list.insert('', tk.END, values=(
                expense['id'],
                expense['date'], 
                expense['category'], 
                f"${expense['amount']:.2f}"
            ))

        # Update Total Label
        self.total_label.config(text=f"Total Displayed Expenses: ${filtered_total:.2f}")


if __name__ == "__main__":
    # 1. Initialize the root GUI window
    root = tk.Tk()
    
    # 2. Initialize the Expense Tracker (Model)
    tracker = ExpenseTracker()

    # reset for testing
    # tracker._reset_expenses()

    # (Add initial dummy data for testing)
    # tracker.add_expense(50.00, "Food", "2025-10-01")
    # tracker.add_expense(1200.00, "Rent", "2025-10-03")
    # tracker.add_expense(15.75, "Transport", "2025-10-05")
    # tracker.add_expense(80.00, "Clothes", "2025-10-07")
    
    # 3. Initialize the GUI (View), passing the Model to it
    app = ExpenseTrackerGUI(root, tracker)
    
    # 4. Start the GUI loop
    root.mainloop()